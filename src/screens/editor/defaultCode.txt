class Tank {
    constructor(game, previousTank) {
        // Every time you submit your code, a new object is created.
        // The previous object is passed through the constructor as `previousTank`
        // so you can save/copy the values you want to persist.

        // These values must be updated by you, which will be sent to the server
        this.appliedForce = previousTank.appliedForce;
        this.rotation = previousTank.rotation;
        this.lastXBuffer = previousTank.lastXBuffer || 0;
        this.lastYBuffer = previousTank.lastYBuffer || 0;
        this.lastX = previousTank.lastX || 0;
        this.lastY = previousTank.lastY || 0;

        // These values will be updated by the server
        this.x = 0;
        this.y = 0;
        this.size = 0;
        this.heading = 0;

        window.onkeydown = (e) => {
            if (e.code == "ArrowUp") {
                this.appliedForce = 1000;
            } else if (e.code == "ArrowDown") {
                this.appliedForce = -1000;
            } else if (e.code == "ArrowLeft") {
                this.rotation = -10;
            } else if (e.code == "ArrowRight") {
                this.rotation = 10;
            }
        };
        window.onkeyup = (e) => {
            this.appliedForce = 0;
            this.rotation = 0;
        }
    }

    render() {
        // Render your own GUI here
    }

    step(step) {
        // Determine new acceleration and rotation values here
        this.lastX = this.lastXBuffer;
        this.lastY = this.lastYBuffer;
        this.lastXBuffer = this.x;
        this.lastYBuffer = this.y;
    }

    getVelocity() {
        const velocityVector = [0, 0];
        velocityVector[0] = this.x - this.lastX;
        velocityVector[1] = this.y - this.lastY;
        const velocity = Math.sqrt(Math.pow(velocityVector[0], 2) + Math.pow(velocityVector[1], 2));
        return velocity;
    }
}
